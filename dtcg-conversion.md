# Figma to Design Tokens Community Group (DTCG) Conversion Architecture

## 1. Overview

### 1.1. Goal
The primary goal of this architecture is to define a clear process for transforming the detailed Figma variables payload (as fetched by the logic in `code.js` and described in `data-fetching-flow.md`) into the standardized Design Tokens Community Group (DTCG) JSON format. This will enable interoperability with tools that support the DTCG standard.

### 1.2. Source Data: Figma Variables Payload
The source data is the `allFetchedVariablesPayload` JavaScript object generated by the Figma plugin. This object contains two main arrays:
*   `local`: Variables defined directly in the current Figma file.
*   `shared`: Variables imported from enabled team libraries.

Each array contains collection objects, which in turn contain variable objects. Key properties of a variable include `name`, `description`, `resolvedType`, `valuesByMode` (mapping mode IDs to values, which can be direct values or aliases), `scopes`, and `codeSyntax`.

**Important Note on Mode Names for Shared Collections:**
The current `code.js` initializes `modes: []` for shared collections. However, the `LibraryVariableCollection` object from `figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync()` includes a `modes` property. To ensure mode names are available for shared variables, the data fetching logic in `code.js` for shared collections should be updated:
```javascript
// In fetchSharedCollections function, when creating sharedCollectionData:
const sharedCollectionData = {
  // ... other properties
  modes: libraryCollection.modes.map(mode => ({ modeId: mode.modeId, name: mode.name })), // Populate this
  variables: []
};
```
This change is crucial for the conversion process to correctly use mode names.

### 1.3. Target Format: DTCG Payload
The target is a JSON object adhering to the [Design Tokens Format Module specification](https://tr.designtokens.org/format/). Key aspects include:
*   Tokens are defined with `$value` and `$type`.
*   Optional properties: `$description`, `$extensions`.
*   Hierarchical structure using nested JSON objects for groups.
*   Aliases are represented as string references: `{path.to.another.token}`.

## 2. Key Architectural Decisions

### 2.1. Handling Modes
Figma modes will be translated into nested groups within the DTCG structure. Each collection will contain groups named after its modes, and these mode groups will then contain the variable hierarchy.

Example:
```json
"collectionName": {
  "modeName1": {
    "variableGroup": {
      "variableName": { "$type": "...", "$value": "..." }
    }
  },
  "modeName2": {
    // ...
  }
}
```

### 2.2. Token Naming and Grouping
*   Figma collection names will serve as top-level groups in the DTCG structure.
*   Figma variable names containing slashes (e.g., `path/to/variable`) will be parsed into nested groups under their respective mode group.
    *   Example: `colors/primitive/blue` becomes `colors.primitive.blue`.

### 2.3. Alias (Reference) Resolution Strategy
1.  A map (`figmaVariableIdToDTCGPathMap`) will be built, storing the canonical, mode-agnostic DTCG path for every Figma variable ID.
    *   Path example: `collectionName.variablePath.from.name`.
2.  When a Figma variable's value is an alias (`{ type: 'VARIABLE_ALIAS', id: 'targetVariableId' }`), its DTCG `$value` will be constructed using the target variable's path from this map, formatted as `{dtcg.path.to.target}`.

### 2.4. Type Mapping Strategy
Figma's `resolvedType` will be mapped to DTCG `$type` values.
*   `COLOR` -> `color`
*   `FLOAT` -> `dimension` (defaulting to `px` units) or `number` (context-dependent, initially `dimension`)
*   `STRING` -> `string` (could be refined to `fontFamily` with heuristics later)
*   `BOOLEAN` -> `boolean`

Specific `$value` structures for each type will be adhered to (e.g., object for `color`, `dimension`).

### 2.5. Use of `$extensions`
Figma-specific metadata will be stored under a namespaced `$extensions` object to preserve information without conflicting with the DTCG standard.
The proposed namespace is `com.figma`.
Properties to store: `variableId`, `originalKey` (for shared vars), `scopes`, `codeSyntax`, `remote` status, `libraryName`.

## 3. Core Data Structures

### 3.1. Final `DTCGPayload` (Illustrative Snippet)
```json
{
  "Enso Design System Colors": { // Collection Name
    "light": { // Mode Name
      "workflow": { // Group from variable name
        "connector": { // Token name
          "$type": "color",
          "$value": "{Enso Design System Colors.light.base.gray.500}", // Example alias
          "$description": "Connector color for workflows",
          "$extensions": {
            "com.figma": {
              "variableId": "VariableID:8195:23",
              "originalKey": "ad4abd5f1942c2e0f03a167222c15ddbb7621c11",
              "scopes": ["STROKE_COLOR"],
              "codeSyntax": { "WEB": "var(--color-workflow-border-connector)" },
              "remote": true,
              "libraryName": "Enso Design System"
            }
          }
        }
      }
    },
    "dark": { /* ... similar structure for dark mode ... */ }
  },
  "Local Primitives": { /* ... another collection ... */ }
}
```

### 3.2. `FigmaVariableIdToDTCGPathMap`
A JavaScript `Map` object where:
*   **Key:** Figma Variable ID (e.g., `"VariableID:8195:23"`).
*   **Value:** Canonical, mode-agnostic DTCG path string (e.g., `"enso_colors.workflow.connector"`). This path is constructed from the collection name and the variable's own name/path.

## 4. Functional Breakdown (The Pipeline)

The conversion process will be orchestrated by a main function, utilizing several helper functions. These functions would typically reside in a new module (e.g., `dtcgConverter.js` imported into `code.js`) or be added directly to `code.js`.

### 4.1. `buildFigmaIdToDTCGPathMap(allFetchedVariablesPayload)`

*   **Purpose:** To create a comprehensive mapping from every Figma variable's local ID to its canonical DTCG path. This map is crucial for resolving aliases correctly.
*   **Inputs:**
    *   `allFetchedVariablesPayload`: The complete Figma variables data object.
*   **Outputs:**
    *   `Map<String, String>`: The `figmaVariableIdToDTCGPathMap`.
*   **Logic:**
    1.  Initialize an empty `Map`.
    2.  Iterate through `allFetchedVariablesPayload.local` and `allFetchedVariablesPayload.shared` collections.
    3.  For each `collection`:
        *   For each `figmaVariable` within `collection.variables`:
            *   Construct the DTCG path:
                *   Start with the `collection.name` (sanitize if necessary, e.g., replace spaces with underscores or use camelCase).
                *   Parse `figmaVariable.name` (which can contain `/` for grouping). Replace `/` with `.` to form the rest of the path.
                *   Example: `collection.name = "Enso Colors", figmaVariable.name = "core/primitive/blue"` becomes path `"EnsoColors.core.primitive.blue"`.
            *   Store the mapping: `map.set(figmaVariable.id, generatedDtcgPath)`.

### 4.2. `transformFigmaValueToDTCGValue(figmaValue, figmaResolvedType, figmaVariableContext, idToPathMap, allFetchedVariablesPayload)`

*   **Purpose:** To convert a single Figma variable value (for a specific mode) into its corresponding DTCG `$value` representation, handling type conversions and alias resolution.
*   **Inputs:**
    *   `figmaValue`: The value object/primitive from `figmaVariable.valuesByMode[modeId]`.
    *   `figmaResolvedType`: The `resolvedType` of the Figma variable (e.g., `'COLOR'`, `'FLOAT'`).
    *   `figmaVariableContext`: The full Figma variable object (for access to `scopes`, `name` if needed for contextual type conversion).
    *   `idToPathMap`: The `figmaVariableIdToDTCGPathMap` for resolving aliases.
    *   `allFetchedVariablesPayload`: The entire dataset, potentially needed if alias resolution requires looking up the aliased variable's original collection/mode context (though ideally, the `idToPathMap` is sufficient for path construction).
*   **Outputs:**
    *   The DTCG-compatible `$value` (e.g., a string for an alias, an object for color/dimension).
*   **Logic (using a switch or if/else on `figmaResolvedType`):**
    *   **If `figmaValue.type === 'VARIABLE_ALIAS'`:**
        1.  Get the `targetVariableId = figmaValue.id`.
        2.  Look up `targetDtcgPath = idToPathMap.get(targetVariableId)`.
        3.  If found, return `"{${targetDtcgPath}}"`.
        4.  If not found, log a warning and return a placeholder or error indicator (e.g., `"{UNRESOLVED_ALIAS:${targetVariableId}}"`)
    *   **`COLOR`:**
        *   Input `figmaValue` is `{r, g, b, a}` (all 0-1).
        *   Call `convertFigmaColorToDTCG(figmaValue)`:
            *   Returns `{"colorSpace": "srgb", "components": [figmaValue.r, figmaValue.g, figmaValue.b], "alpha": figmaValue.a}`.
    *   **`FLOAT`:**
        *   Input `figmaValue` is a number.
        *   Call `convertFigmaFloatToDTCGDimension(figmaValue)`:
            *   Default unit: `"px"`. (Consider making unit configurable or inferable from `figmaVariableContext.scopes` or `figmaVariableContext.name` in the future).
            *   Returns `{"value": figmaValue, "unit": "px"}`.
    *   **`STRING`:**
        *   Input `figmaValue` is a string.
        *   Return the string directly. (Future: Check `figmaVariableContext.scopes` or name patterns to potentially identify as `fontFamily`).
    *   **`BOOLEAN`:**
        *   Input `figmaValue` is a boolean.
        *   Return the boolean directly.
    *   **Default/Unknown:** Log a warning and return the `figmaValue` as is, or a placeholder.

#### Sub-helper: `convertFigmaColorToDTCG(figmaColor)` as described above.
#### Sub-helper: `convertFigmaFloatToDTCGDimension(floatValue, unit = "px")` as described above.

### 4.3. `createDTCGTokenObject(figmaVariable, modeName, modeValue, idToPathMap, allFetchedVariablesPayload)`

*   **Purpose:** To construct a complete DTCG token object (including `$type`, `$value`, `$description`, `$extensions`) for a given Figma variable in a specific mode.
*   **Inputs:**
    *   `figmaVariable`: The full Figma variable object.
    *   `modeName`: The string name of the current mode (e.g., "light", "dark").
    *   `modeValue`: The actual value of the variable for this mode (from `figmaVariable.valuesByMode[modeId]`).
    *   `idToPathMap`: The `figmaVariableIdToDTCGPathMap`.
    *   `allFetchedVariablesPayload`: For context if `transformFigmaValueToDTCGValue` needs it.
*   **Outputs:**
    *   A DTCG token object (e.g., `{ "$type": "color", "$value": "...", ... }`).
*   **Logic:**
    1.  Determine `$type`:
        *   Map `figmaVariable.resolvedType` to DTCG type string (e.g., `COLOR` -> `"color"`).
    2.  Calculate `$value`:
        *   Call `transformFigmaValueToDTCGValue(modeValue, figmaVariable.resolvedType, figmaVariable, idToPathMap, allFetchedVariablesPayload)`.
    3.  Set `$description`:
        *   `figmaVariable.description || ""`
    4.  Construct `$extensions`:
        *   Create an object:
          ```json
          "$extensions": {
            "com.figma": {
              "variableId": figmaVariable.id,
              "originalKey": figmaVariable.originalKey || null, // Only for shared
              "scopes": figmaVariable.scopes,
              "codeSyntax": figmaVariable.codeSyntax,
              "remote": figmaVariable.remote,
              "libraryName": figmaVariable.libraryName || null // Only for shared
            }
          }
          ```
    5.  Return the complete DTCG token object: `{ "$type": type, "$value": value, "$description": description, "$extensions": extensions }`.

### 4.4. `generateDTCGPayload(allFetchedVariablesPayload)` (Main Orchestrator)

*   **Purpose:** The main function to drive the entire conversion from the raw Figma payload to the final DTCG JSON object.
*   **Inputs:**
    *   `allFetchedVariablesPayload`: The complete Figma variables data.
*   **Outputs:**
    *   `Object`: The complete DTCG JSON payload.
*   **Logic:**
    1.  Initialize `finalDTCGObject = {}`.
    2.  Call `idToPathMap = buildFigmaIdToDTCGPathMap(allFetchedVariablesPayload)`.
    3.  Iterate through combined `allFetchedVariablesPayload.local` and `allFetchedVariablesPayload.shared` collections. For each `collection`:
        *   Sanitize `collection.name` for use as a DTCG group key (e.g., `collectionKey = sanitizeName(collection.name)`).
        *   `finalDTCGObject[collectionKey] = {};`
        *   Iterate through `collection.modes`. For each `mode` object (`{modeId, name}`):
            *   Sanitize `mode.name` for use as a DTCG group key (e.g., `modeKey = sanitizeName(mode.name)`).
            *   `finalDTCGObject[collectionKey][modeKey] = {};`
            *   Iterate through `collection.variables`. For each `figmaVariable`:
                *   Get `modeValue = figmaVariable.valuesByMode[mode.modeId]`.
                *   If `modeValue` is undefined (variable might not have a value for this mode), skip or log a warning.
                *   If `modeValue` exists:
                    *   Call `dtcgToken = createDTCGTokenObject(figmaVariable, mode.name, modeValue, idToPathMap, allFetchedVariablesPayload)`.
                    *   Parse `figmaVariable.name` into path segments (e.g., `"group/sub/token"` -> `["group", "sub", "token"]`). Let the last segment be `tokenName` and preceding segments be `pathSegments`.
                    *   Use a helper `deepSet(targetObject, pathArray, value)` to place the token:
                        *   `target = finalDTCGObject[collectionKey][modeKey]`
                        *   `fullPathArray = pathSegments.concat(tokenName)`
                        *   `deepSet(target, fullPathArray, dtcgToken)`
                        *   (The `deepSet` needs to place the `dtcgToken` at the `tokenName` level, and `tokenName` itself should not have a `$value` directly if it's part of a path leading to a token).
                        *   More accurately, the `tokenName` is the key for the `dtcgToken`. So, `deepSet(target, pathSegments, tokenName, dtcgToken)` or `deepSet(target, pathSegments)[tokenName] = dtcgToken`.
                        Let's refine `deepSet`: the path leads to a *group* where the token (named by the last segment of its original name) will reside.
                        So, `tokenKey = pathSegments.pop()`. The `pathSegments` now define the group structure.
                        `parentGroup = deepEnsurePath(finalDTCGObject[collectionKey][modeKey], pathSegments);`
                        `parentGroup[tokenKey] = dtcgToken;`

### 4.5. Utility: `deepEnsurePath(obj, pathArray)`

*   **Purpose:** Ensures a nested path of objects exists within a target object. If any part of the path doesn't exist, it's created as an empty object.
*   **Inputs:**
    *   `obj`: The target object to modify.
    *   `pathArray`: An array of strings representing the path segments.
*   **Outputs:**
    *   The deepest object in the path.
*   **Logic:**
    ```javascript
    function deepEnsurePath(obj, pathArray) {
      let current = obj;
      for (const segment of pathArray) {
        if (!current[segment]) {
          current[segment] = {};
        }
        current = current[segment];
      }
      return current;
    }
    ```

### 4.6. Utility: `sanitizeName(name)`
*   **Purpose:** To sanitize collection, mode, or variable names/path segments for use as valid JSON keys and DTCG group/token names (e.g., replace spaces, special characters).
*   **Inputs:** `name` (string).
*   **Outputs:** Sanitized name (string).
*   **Logic:** (Example: replace spaces with underscores, remove disallowed characters. Exact rules depend on desired DTCG naming convention). For now, a simple replacement: `name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_.-]/g, '')`.

## 5. Detailed Mapping and Conventions

### 5.1. Figma Variable Properties to DTCG Token Properties

| Figma Property         | DTCG Property      | Transformation/Notes                                                                                                                              |
| ---------------------- | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| `variable.name`        | Path & Token Name  | Parsed: `group/sub/token` -> `group.sub.token`. Last part is token name. Stored under collection & mode groups.                                   |
| `variable.description` | `$description`     | Direct mapping. Defaults to empty string if null/undefined.                                                                                       |
| `variable.resolvedType`| `$type`            | Mapped: `COLOR`->`color`, `FLOAT`->`dimension`, `STRING`->`string`, `BOOLEAN`->`boolean`.                                                          |
| `variable.valuesByMode[modeId]` | `$value`   | Transformed based on `$type`. Aliases resolved to `{path.to.token}`. Colors to DTCG color object. Floats to dimension object.                       |
| `variable.id`          | `$extensions.com.figma.variableId` | Stored for traceability.                                                                                                          |
| `variable.originalKey` (shared) | `$extensions.com.figma.originalKey` | Stored for shared variables.                                                                                             |
| `variable.scopes`      | `$extensions.com.figma.scopes` | Array of strings, stored as is.                                                                                                   |
| `variable.codeSyntax`  | `$extensions.com.figma.codeSyntax` | Object, stored as is.                                                                                                             |
| `variable.remote`      | `$extensions.com.figma.remote` | Boolean, stored as is.                                                                                                            |
| `variable.libraryName` (shared) | `$extensions.com.figma.libraryName` | String, stored for shared variables.                                                                                     |
| `collection.name`      | Top-level Group Key| Root group for all tokens from that collection.                                                                                                   |
| `collection.modes[i].name` | Mid-level Group Key| Group under collection, for tokens in that specific mode.                                                                                    |

### 5.2. `$extensions` Namespace and Content
*   **Namespace:** `com.figma`
*   **Content:**
    *   `variableId: string`
    *   `originalKey?: string`
    *   `scopes: string[]`
    *   `codeSyntax: object`
    *   `remote: boolean`
    *   `libraryName?: string`

## 6. Code Location and Structure

*   **Recommendation:** Create a new file, e.g., `dtcgConverter.js`, to house all conversion-related functions. This module can then be imported and used in `code.js`.
    ```javascript
    // dtcgConverter.js
    export function generateDTCGPayload(allFetchedVariablesPayload) { /* ... */ }
    // ... other helper functions, possibly not exported if internal ...
    ```
*   **Alternatively:** Add these functions directly to `code.js` if the project structure prefers a single file for plugin logic.
*   **Function Signatures (as defined in Section 4):**
    *   `buildFigmaIdToDTCGPathMap(allFetchedVariablesPayload)`
    *   `transformFigmaValueToDTCGValue(figmaValue, figmaResolvedType, figmaVariableContext, idToPathMap, allFetchedVariablesPayload)`
    *   `convertFigmaColorToDTCG(figmaColor)`
    *   `convertFigmaFloatToDTCGDimension(floatValue, unit = "px")`
    *   `createDTCGTokenObject(figmaVariable, modeName, modeValue, idToPathMap, allFetchedVariablesPayload)`
    *   `generateDTCGPayload(allFetchedVariablesPayload)`
    *   `deepEnsurePath(obj, pathArray)`
    *   `sanitizeName(name)`

## 7. Example Transformation (Simplified)

**Figma Input Snippet (`allFetchedVariablesPayload.local[0]`):**
```json
{
  "id": "VariableCollectionId:1:10",
  "name": "Brand Colors",
  "modes": [{ "modeId": "1:0", "name": "Default" }],
  "defaultModeId": "1:0",
  "variables": [
    {
      "id": "VariableID:1:100",
      "name": "action/primary/background",
      "description": "Main action button background",
      "resolvedType": "COLOR",
      "valuesByMode": { "1:0": { "r": 0.2, "g": 0.4, "b": 0.8, "a": 1 } },
      "scopes": ["SHAPE_FILL"],
      "codeSyntax": {}, "remote": false
    },
    {
      "id": "VariableID:1:101",
      "name": "spacing/small",
      "description": "Small spacing value",
      "resolvedType": "FLOAT",
      "valuesByMode": { "1:0": 8 },
      "scopes": ["GAP","WIDTH_HEIGHT"],
      "codeSyntax": {}, "remote": false
    }
  ],
  "remote": false
}
```

**`figmaVariableIdToDTCGPathMap` would include:**
*   `"VariableID:1:100"` -> `"Brand_Colors.action.primary.background"`
*   `"VariableID:1:101"` -> `"Brand_Colors.spacing.small"`

**Resulting DTCG Snippet:**
```json
{
  "Brand_Colors": {
    "Default": {
      "action": {
        "primary": {
          "background": {
            "$type": "color",
            "$value": { "colorSpace": "srgb", "components": [0.2, 0.4, 0.8], "alpha": 1 },
            "$description": "Main action button background",
            "$extensions": {
              "com.figma": {
                "variableId": "VariableID:1:100", "scopes": ["SHAPE_FILL"], /* ... other figma props ... */
              }
            }
          }
        }
      },
      "spacing": {
        "small": {
          "$type": "dimension",
          "$value": { "value": 8, "unit": "px" },
          "$description": "Small spacing value",
          "$extensions": {
            "com.figma": {
              "variableId": "VariableID:1:101", "scopes": ["GAP","WIDTH_HEIGHT"], /* ... */
            }
          }
        }
      }
    }
  }
}
```

## 8. Future Considerations / Advanced Topics

*   **Composite Types:** Mapping sets of Figma variables (e.g., `font-family`, `font-size`, `font-weight`) to DTCG composite types like `typography`. This would require defining naming conventions or using special grouping in Figma to identify these sets.
*   **User Configuration:**
    *   Allowing users to specify default units for `FLOAT` -> `dimension` conversion.
    *   Configuration for type mapping hints (e.g., "variables named `*-font-*` should be `fontFamily`").
    *   Customizing the `com.figma` extension key or content.
*   **Enhanced Alias Resolution:** Handling cases where an alias might point to a variable that couldn't be imported or processed, providing clearer error feedback in the DTCG output.
*   **Selective Export:** Allowing users to select which collections or modes to export.
*   **Error Handling:** Robust error handling within each conversion function, logging issues, and potentially providing a summary of conversion errors.
*   **File Output:** Integrating this logic to eventually output the `DTCGPayload` as a `.json` file.
*   **Advanced Sanitization:** More sophisticated name sanitization to ensure compatibility with various systems consuming DTCG tokens.

This architecture provides a comprehensive plan for the conversion. Remember to address the identified gap regarding mode name population for shared collections in your existing Figma data fetching logic.
