<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --figma-color-text: #FFFFFF;
      --tab-wrapper-bg: #2C2C2C;
      --tab-wrapper-border: #444444;
      --tab-button-padding: 6px 10px;
      --tab-button-radius: 4px;
      --tab-button-font: inherit;
      --tab-button-font-size: 11px;
      --tab-button-font-weight: 500;
      --tab-button-letter-spacing: normal;
      --tab-default-text-color: #A0A0A0;
      --tab-default-opacity: 1;
      --tab-active-text-color: #FFFFFF;
      --tab-active-opacity: 1;
      --tab-active-bg: #3C3C3C; 
      /* Add new variables for the warning banner */
      --warning-banner-bg: #4E3534; /* Updated darker red background */
      --warning-banner-text: #FADEDC; /* Updated light pink/peach text */
    }

    body {
      font-family: 'Geist Mono', 'Roboto Mono', monospace; /* Changed from Inter */
      margin: 0;
      font-size: 11px;
      color: var(--figma-color-text);
      min-height: 0; /* Keeping this for now, might be useful for nested flex */
      overflow: hidden;
      /* display: flex; Removed to allow container to fill body */
      height: 100vh; /* Make body take full viewport height */
    }

    .tab-wrapper {
      display: flex;
      flex-shrink: 0;
      padding: 10px; /* Correct */
      /* gap: 2px; Removed - moved to inner group */
      background-color: var(--tab-wrapper-bg); /* Correct (#2C2C2C) */
      border-bottom: 1px solid var(--tab-wrapper-border); /* Corrected typo and Correct (#444444) */
      /* width: 100%; Removed - Should hug content based on Figma */
      /* box-sizing: border-box; Removed */
      align-items: center; /* Added */
    }

    /* New inner container for buttons to apply the gap */
    .tab-button-group {
        display: flex;
        align-items: center;
        gap: 2px; /* Gap applied here, as in Figma's inner Frame 7 */
    }

    /* Base styles for all tab buttons */
    .tab-button {
      padding: var(--tab-button-padding);
      border-radius: var(--tab-button-radius);
      font-family: var(--tab-button-font);
      font-size: var(--tab-button-font-size);
      font-weight: var(--tab-button-font-weight);
      letter-spacing: var(--tab-button-letter-spacing);
      border: none;
      background: none;
      cursor: pointer;
      text-align: center;
      /* Default State */
      color: var(--tab-default-text-color);
      opacity: var(--tab-default-opacity);
      transition: background-color 0.2s, color 0.2s, opacity 0.2s;
    }

    /* Active state for all tab buttons */
    .tab-button.active {
      color: var(--tab-active-text-color);
      opacity: var(--tab-active-opacity);
      background-color: var(--tab-active-bg);
    }

    /* Hover state for all non-active tab buttons */
    .tab-button:hover:not(.active) {
      /* Use active style for hover based on Figma */
      color: var(--tab-active-text-color);
      opacity: var(--tab-active-opacity);
      background-color: var(--tab-active-bg);
    }

    /* View containers / Tab Content */
    .tab-content {
      display: none;
      height: 100%;
      overflow: auto;
      box-sizing: border-box;
    }

    .tab-content.active {
      display: flex;
      flex-direction: row;
      width: 100%;
      /* No gap here, border on tree-area handles separation */
    }

    .views-container {
      display: flex;
      flex-grow: 1;
      min-height: 0;
      overflow: hidden; /* or auto */
    }

    .container {
      display: flex;
      flex-direction: row; /* Changed from column to row for horizontal layout */
      height: 100%;
      width: 100%; /* ADDED */
      overflow: hidden; /* Prevent unwanted scrollbars */
    }
    
    .header {
      display: none; /* Hide the header */
    }
    
    /* Flex wrapper for main content areas */
    .content-wrapper {
      display: flex;
      flex-direction: column; /* Keep column for tabs on top */
      flex-grow: 1;
      min-height: 0; /* Important for nested flex containers */
      overflow: hidden;
    }

    #tree-area {
      flex-basis: 33%; /* Takes roughly 1/3 of the space */
      flex-grow: 1;
      max-width: 30%; /* Added to cap width */
      padding: 12px; /* Updated from 10px */
      border-right: 1px solid var(--tab-wrapper-border); /* Consistent border */
      box-sizing: border-box;
      overflow-y: auto; /* Allow scrolling if content overflows */
      display: flex; /* Added for internal layout */
      flex-direction: column; /* Added for internal layout */
      gap: 12px; /* Added for internal layout */
    }

    #output-area {
      flex-basis: 67%; /* Takes roughly 2/3 of the space */
      flex-grow: 1;
      padding: 12px; /* Updated from 10px */
      box-sizing: border-box;
      overflow-y: auto; /* Allow scrolling if content overflows */
      display: flex; /* Added for internal layout */
      flex-direction: column; /* Added for internal layout */
      gap: 12px; /* Added for internal layout */
    }

    /* JSON viewer styles */
    /* Output Area Header styles */
    #output-area-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      flex-shrink: 0;
    }

    /* Action buttons group */
    .action-button-group {
      display: flex;
      gap: 2px;
    }

    /* Output Area Code styles */
    #output-area-code {
      flex-grow: 1;
      min-height: 0;
      background-color: #1E1E1E;
      border-radius: 4px;
      overflow: hidden;
      display: flex;
    }

    /* Output code content styles */
    .output-code-content {
      display: none;
      width: 100%;
      height: 100%;
      overflow-y: auto;
      padding: 12px;
      box-sizing: border-box;
    }

    .output-code-content.active {
      display: block;
    }

    /* Add styling for the json-viewer */
    .json-viewer {
      margin: 0;
      padding: 0;
      font-family: 'Geist Mono', 'Roboto Mono', monospace;
      font-size: 11px;
      line-height: 1.5;
      white-space: pre-wrap;
    }

    /* Checkbox tree styles */
    .checkbox-tree {
      list-style-type: none;
      padding-left: 0;
      margin: 0;
      font-family: 'Geist Mono', 'Roboto Mono', monospace;
      font-size: 11px;
    }

    .checkbox-tree ul {
      list-style-type: none;
      padding-left: 16px; /* Changed from 20px to 16px */
      margin: 0;
      /* Add display: none by default for collapsed state */
      display: none;
    }

    /* Show children when parent has expanded class */
    .checkbox-tree li.expanded > ul {
      display: block;
    }

    .checkbox-tree li {
      margin: 4px 0; /* Reduced from 6px to 4px in y-axis */
    }

    .checkbox-item {
      display: flex;
      align-items: center;
      /* Add justify-content to position chevron on the right */
      justify-content: space-between;
      cursor: pointer;
      padding: 2px; /* Add 2px padding all around */
      border-radius: 4px; /* Add 4px corner radius */
      transition: background-color 0.2s ease; /* Smooth transition for hover effect */
    }

    /* Add hover state for checkbox-item */
    .checkbox-item:hover {
      background-color: #282828; /* Background color on hover */
    }

    .checkbox-label {
      margin-left: 6px;
      cursor: pointer;
      user-select: none; /* Prevent text selection */
      color: var(--figma-color-text);
    }

    /* Checkbox & label container */
    .checkbox-label-container {
      display: flex;
      align-items: center;
    }

    /* Chevron styles */
    .chevron-icon {
      width: 12px;
      height: 12px;
      transition: transform 0.2s ease;
      opacity: 0;
    }

    /* Show chevron on hover for collapsed items */
    .checkbox-item:hover .chevron-icon {
      opacity: 0.8;
    }

    /* Always show chevron for expanded items */
    .expanded > .checkbox-item .chevron-icon {
      opacity: 0.8;
      transform: rotate(0deg);
    }

    /* Rotate chevron for collapsed items */
    .chevron-icon {
      transform: rotate(-90deg);
    }

    /* Custom checkbox styling to match Figma's design */
    .checkbox-tree input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      border: 1px solid #666;
      border-radius: 4px;
      background-color: transparent;
      display: inline-block;
      position: relative;
      cursor: pointer;
      vertical-align: middle;
    }

    .checkbox-tree input[type="checkbox"]:checked {
      background-color: #ffffff;
      border-color: #ffffff;
    }

    .checkbox-tree input[type="checkbox"]:checked::after {
      content: '';
      position: absolute;
      left: 3px;
      top: 1px;
      width: 3px;
      height: 6px;
      border: solid rgb(0, 0, 0);
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }

    .checkbox-tree input[type="checkbox"]:indeterminate {
      background-color: #272727;
      
    }

    .checkbox-tree input[type="checkbox"]:indeterminate::after {
      content: '';
      position: absolute;
      top: 5px;
      right: 3.5px;
      width: 5px;
      height: 2px;
      background-color: white;
    }

    /* New styles for the warning banner */
    .warning-banner {
      background-color: var(--warning-banner-bg);
      color: var(--warning-banner-text);
      padding: 12px;
      border-radius: 4px;
      font-size: 10px;
      line-height: 1.6;
      display: none; /* Hidden by default */
      position: relative; /* For positioning the close button */
    }

    .warning-banner p {
      margin: 0;
      padding-right: 20px; /* Space for the close button */
    }

    .warning-banner .close-btn {
      position: absolute;
      top: 16px;
      right: 10px;
      background: none;
      border: none;
      color: var(--warning-banner-text);
      font-size: 18px;
      font-weight: 500;
      cursor: pointer;
      opacity: 0.7;
    }
    .warning-banner .close-btn:hover {
      opacity: 1;
    }
    /* End of new styles for warning banner */

  </style>
</head>
<body>
  <!-- Remove the warning banner from here -->
  <!--
  <div id="global-warning-banner" class="warning-banner">
    <p id="global-warning-message"></p>
    <button class="close-btn" onclick="document.getElementById('global-warning-banner').style.display = 'none';">&times;</button>
  </div>
  -->

  <div class="container">
    <!-- The old header is hidden -->
    <!-- <div class="header">...</div> -->
    
    <div class="content-wrapper">
      <!-- New Tab Navigation -->
      <div class="tab-wrapper">
        <div class="tab-button-group"> <!-- Added inner group -->
          <button class="tab-button active" data-target="variables-view">Variables</button>
          <button class="tab-button" data-target="styles-view">Styles</button>
          <button class="tab-button" data-target="github-view">Export to Github</button>
          <button class="tab-button" data-target="settings-view">Settings</button>
        </div> <!-- Closed inner group -->
      </div>
      
      <!-- Old view selector removed -->
      <!-- <div class="view-selector-container">...</div> -->

      <div class="views-container">
        <!-- Variables View -->
        <div class="tab-content active" id="variables-view">
          <div id="tree-area">
            <div id="variables-tree">
              <div class="spinner"></div>
            </div>
          </div>
          <div id="output-area">
            <!-- Output Area Header with tabs -->
            <div id="output-area-header">
              <div class="tab-button-group"> <!-- For JSON, CSS, Tailwind tabs -->
                <button class="tab-button output-tab-button active" data-target="json-code-content">JSON</button>
                <button class="tab-button output-tab-button" data-target="js-code-content">Js</button>
                <button class="tab-button output-tab-button" data-target="css-code-content">CSS</button>
                <button class="tab-button output-tab-button" data-target="tailwind-code-content">Tailwind</button>
              </div>
              <div class="action-button-group"> <!-- For Download and Copy buttons -->
                <button class="tab-button" id="export-github-btn">Export to Github</button>
                <button class="tab-button" id="download-code-btn">Download code</button>
                <button class="tab-button" id="copy-code-btn">Copy to clipboard</button>
              </div>
            </div>

            <!-- Add the warning banner here, between header and code output -->
            <div id="global-warning-banner" class="warning-banner">
              <p id="global-warning-message">Some variable aliases couldn't be resolved due to missing libraries â€” please enable all required Figma libraries and restart the plugin.</p>
              <button class="close-btn" onclick="document.getElementById('global-warning-banner').style.display = 'none';">&times;</button>
            </div>

            <!-- Output Area Code (scrollable content) -->
            <div id="output-area-code">
              <!-- JSON Content Pane -->
              <div id="json-code-content" class="output-code-content active">
                <!-- Remove the warning banner from here -->
                
                <p id="json-initial-message" style="margin: 0;">Select a collection, mode, or variable in the tree to view details.</p>
                <pre class="json-viewer" style="display: none;"></pre> <!-- JSON code will go here -->
              </div>
              <!-- Js Content Pane (Placeholder) -->
              <div id="js-code-content" class="output-code-content">
                <p style="margin: 0;">Select a collection, mode, or variable in the tree to view details.</p>
              </div>
              <!-- CSS Content Pane (Placeholder) -->
              <div id="css-code-content" class="output-code-content">
                <p style="margin: 0;">Select a collection, mode, or variable in the tree to view details.</p>
              </div>
              <!-- Tailwind Content Pane (Placeholder) -->
              <div id="tailwind-code-content" class="output-code-content">
                <p style="margin: 0;">Select a collection, mode, or variable in the tree to view details.</p>
              </div>
            </div>
          </div>
        </div>
      
        <!-- Styles View -->
        <div class="tab-content" id="styles-view">
          <div id="tree-area">
            Tree Area (Styles)
          </div>
          <div id="output-area">
            Output Area (Styles)
          </div>
        </div>
        
        <!-- GitHub Export View (Placeholder) -->
        <div class="tab-content" id="github-view">
          <div id="output-area">
            Output Area (Github)
          </div>
         </div>

        <!-- Settings View (Placeholder) -->
         <div class="tab-content" id="settings-view">
          <div id="output-area">
            Output Area (Settings)
          </div>
         </div>

      <!-- The output-section that was here is now removed -->
      </div> <!-- End of views-container -->
    </div>
  </div>
  <script>
    // Store the original DTCG payload
    let originalDtcgPayload = null;
    
    // Document ready event
    document.addEventListener('DOMContentLoaded', function () {
      // Main tab switching logic
      const tabButtons = document.querySelectorAll('.tab-wrapper .tab-button');
      const tabContents = document.querySelectorAll('.tab-content');

      tabButtons.forEach(button => {
        // Use passive option for touch events to improve scrolling performance
        button.addEventListener('touchstart', () => {
          // Deactivate all buttons and hide all content
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));

          // Activate the clicked button
          button.classList.add('active');

          // Show the target content
          const targetId = button.getAttribute('data-target');
          const targetContent = document.getElementById(targetId);
          if (targetContent) {
            targetContent.classList.add('active');
          }
        }, { passive: true });

        button.addEventListener('click', () => {
          // Deactivate all buttons and hide all content
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));

          // Activate the clicked button
          button.classList.add('active');

          // Show the target content
          const targetId = button.getAttribute('data-target');
          const targetContent = document.getElementById(targetId);
          if (targetContent) {
            targetContent.classList.add('active');
          }
        });
      });
      
      // Setup the output area tabs
      setupOutputAreaTabs();

      // Setup download and copy button functionality
      setupActionButtons();

      // Simplified message handler - properly handle real data and display it
      window.onmessage = async (event) => {
        const msg = event.data.pluginMessage;
        if (!msg) return;

        if (msg.type === 'plugin-info') {
          console.log(msg.payload.message);
        } else if (msg.type === 'dtcgPayload') {
          // console.log("Received dtcgPayload:", msg.payload); // Removed logging
          originalDtcgPayload = msg.payload; // Store the full payload
          renderCheckboxTree(msg.payload);
        } else if (msg.type === 'jsCodePreview') {
          // console.log("Received jsCodePreview:", msg.payload); // Removed logging
          updateJSView(msg.payload);
        } else if (msg.type === 'cssCodePreview') {
          // console.log("Received cssCodePreview:", msg.payload); // Removed logging
          updateCSSView(msg.payload);
        } else if (msg.type === 'tailwindCodePreview') {
          // console.log("Received tailwindCodePreview:", msg.payload); // Removed logging
          updateTailwindView(msg.payload);
        } else if (msg.type === 'error') {
          console.error("Error from plugin:", msg.message);
          // Display error in UI if needed
        } else if (msg.type === 'warning-potential-missing-source') {
          console.warn("Warning from plugin:", msg.payload.message);
          console.warn("Warning details:", msg.payload.details);
          
          const banner = document.getElementById('global-warning-banner');
          const messageEl = document.getElementById('global-warning-message');
          if (banner && messageEl) {
            // Use the improved message from the plugin
            let displayMessage = msg.payload.message;
            
            // Add additional context if details are available
            if (msg.payload.details) {
              const details = msg.payload.details;
              displayMessage += ` (${details.localVariables} local, ${details.sharedVariables} shared variables loaded)`;
            }
            
            messageEl.textContent = displayMessage;
            banner.style.display = 'block';
          }
        }
      };
    });

    // Function to render the checkbox tree from DTCG payload
    function renderCheckboxTree(payload) {
      const treeContainer = document.getElementById('variables-tree');
      treeContainer.innerHTML = ''; // Clear existing content
      
      // Create the root UL element for the tree
      const rootUl = document.createElement('ul');
      rootUl.className = 'checkbox-tree';
      
      // Handle empty payload
      if (!payload || Object.keys(payload).length === 0) {
        treeContainer.innerHTML = `
          <div style="padding: 10px;">
            No variables found. Please ensure your Figma file contains variables.
          </div>
        `;
        return;
      }
      
      // Generate tree structure recursively
      generateTreeNodes(payload, rootUl);
      
      // Append the tree to the container
      treeContainer.appendChild(rootUl);
      
      // Initialize JSON view with empty object to show the "select items" message
      updateJsonView({});
    }
    
    // Recursive function to generate tree nodes
    function generateTreeNodes(data, parentElement, path = []) {
      // Process each key-value pair in the current object
      for (const key in data) {
        const value = data[key];
        const currentPath = [...path, key];
        
        // Create list item
        const li = document.createElement('li');
        li.setAttribute('data-path', currentPath.join('.'));
        
        // Create checkbox item wrapper
        const checkboxItem = document.createElement('div');
        checkboxItem.className = 'checkbox-item';
        
        // Create checkbox label container
        const checkboxLabelContainer = document.createElement('div');
        checkboxLabelContainer.className = 'checkbox-label-container';
        
        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `checkbox-${currentPath.join('-')}`;
        checkbox.setAttribute('data-path', currentPath.join('.'));
        
        // Create label
        const label = document.createElement('label');
        label.className = 'checkbox-label';
        label.htmlFor = checkbox.id;
        label.textContent = key;
        
        // Add title for tooltip on hover (include full path for context)
        label.title = currentPath.join(' > ');
        
        // Add checkbox and label to container
        checkboxLabelContainer.appendChild(checkbox);
        checkboxLabelContainer.appendChild(label);
        
        // Add container to item wrapper
        checkboxItem.appendChild(checkboxLabelContainer);
        
        // Determine if this is a token or a group
        const isToken = value && typeof value === 'object' && '$type' in value && '$value' in value;
        const isGroup = value && typeof value === 'object' && !isToken;
        
        if (isGroup) {
          // This is a branch node with children
          
          // Create chevron for group
          const chevron = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          chevron.setAttribute('width', '12');
          chevron.setAttribute('height', '12');
          chevron.setAttribute('viewBox', '0 0 12 12');
          chevron.setAttribute('fill', 'none');
          chevron.classList.add('chevron-icon');
          
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', 'M3 4.5L6 7.5L9 4.5');
          path.setAttribute('stroke', 'white');
          path.setAttribute('stroke-opacity', '0.8');
          path.setAttribute('stroke-linecap', 'round');
          path.setAttribute('stroke-linejoin', 'round');
          
          chevron.appendChild(path);
          checkboxItem.appendChild(chevron);
          
          // Create child list
          const ul = document.createElement('ul');
          li.appendChild(checkboxItem);
          li.appendChild(ul);
          
          // Recursively generate children
          generateTreeNodes(value, ul, currentPath);
          
          // Setup event listener for this checkbox
          checkbox.addEventListener('change', function(event) {
            handleCheckboxChange(event.target);
          });
          
          // Add click event for expanding/collapsing
          checkboxItem.addEventListener('click', function(e) {
            // Prevent this from triggering when clicking the checkbox directly
            if (e.target !== checkbox) {
              e.preventDefault();
              li.classList.toggle('expanded');
              e.stopPropagation();
            }
          });
        } else {
          // This is a leaf node (token)
          li.appendChild(checkboxItem);
          checkbox.addEventListener('change', function(event) {
            handleCheckboxChange(event.target);
          });
          
          // Add click event for toggling checkbox on leaf nodes
          checkboxItem.addEventListener('click', function(e) {
            // Prevent this from triggering when clicking the checkbox directly
            if (e.target !== checkbox) {
              e.preventDefault();
              checkbox.checked = !checkbox.checked;
              // Trigger the change event manually
              const changeEvent = new Event('change', { bubbles: true });
              checkbox.dispatchEvent(changeEvent);
              e.stopPropagation();
            }
          });
        }
        
        // Add the list item to the parent element
        parentElement.appendChild(li);
      }
    }
    
    // Handle checkbox change events
    function handleCheckboxChange(checkbox) {
      const isChecked = checkbox.checked;
      
      // Propagate state to children (if any)
      propagateStateToChildren(checkbox, isChecked);
      
      // Update parent states
      updateParentStates(checkbox);
      
      // Generate filtered DTCG payload based on current checkbox selections
      const filteredDtcg = generateFilteredDtcgPayload();
      
      // Update the JSON view with the filtered payload
      updateJsonView(filteredDtcg);
      
      // If JS tab is active, also update the JS view
      const jsTab = document.querySelector('[data-target="js-code-content"]');
      if (jsTab && jsTab.classList.contains('active')) {
        // Request JS code generation with the filtered payload
        parent.postMessage({ 
          pluginMessage: { 
            type: 'request-js-code',
            payload: filteredDtcg
          } 
        }, '*');
      }
      
      // If CSS tab is active, also update the CSS view
      const cssTab = document.querySelector('[data-target="css-code-content"]');
      if (cssTab && cssTab.classList.contains('active')) {
        // Request CSS code generation with the filtered payload
        parent.postMessage({ 
          pluginMessage: { 
            type: 'request-css-code',
            payload: filteredDtcg
          } 
        }, '*');
      }
      
      // If Tailwind tab is active, also update the Tailwind view
      const tailwindTab = document.querySelector('[data-target="tailwind-code-content"]');
      if (tailwindTab && tailwindTab.classList.contains('active')) {
        // Request Tailwind code generation with the filtered payload
        parent.postMessage({ 
          pluginMessage: { 
            type: 'request-tailwind-code',
            payload: filteredDtcg
          } 
        }, '*');
      }
    }
    
    // Generate filtered DTCG payload based on checkbox selections
    function generateFilteredDtcgPayload() {
      if (!originalDtcgPayload) {
        return {}; // Safety check
      }

      const filteredOutput = {};
      
      // Process each top-level collection
      for (const collectionName of Object.keys(originalDtcgPayload)) {
        // Process this collection recursively
        const filteredCollection = processNodeRecursively(
          originalDtcgPayload[collectionName],
          [collectionName]
        );
        
        // Only add non-null results to the output
        if (filteredCollection !== null) {
          filteredOutput[collectionName] = filteredCollection;
        }
      }
      
      return filteredOutput;
    }
    
    /**
     * Recursively processes a node and its children based on checkbox states
     * @param {Object} nodeData - The data for this node from the original payload
     * @param {Array} path - Array of strings representing the path to this node
     * @returns {Object|null} - Filtered data or null if this node should be excluded
     */
    function processNodeRecursively(nodeData, path) {
      // Get the checkbox for this node
      const checkbox = findCheckboxByPath(path);
      
      // If checkbox doesn't exist or is unchecked, exclude this branch
      if (!checkbox || (!checkbox.checked && !checkbox.indeterminate)) {
        return null;
      }
      
      // If this node is a leaf (has $type and $value)
      if (nodeData && typeof nodeData === 'object' && nodeData.$type && nodeData.$value !== undefined) {
        // For leaf nodes, only include if explicitly checked
        return checkbox.checked ? JSON.parse(JSON.stringify(nodeData)) : null;
      }
      
      // If the checkbox is checked (not just indeterminate), include the entire subtree
      if (checkbox.checked) {
        return JSON.parse(JSON.stringify(nodeData));
      }
      
      // For indeterminate state, we need to selectively include children
      if (checkbox.indeterminate && typeof nodeData === 'object') {
        const result = {};
        let hasSelectedChildren = false;
        
        // Process each child
        for (const childName of Object.keys(nodeData)) {
          const childPath = [...path, childName];
          const filteredChild = processNodeRecursively(nodeData[childName], childPath);
          
          // Only include non-null results
          if (filteredChild !== null) {
            result[childName] = filteredChild;
            hasSelectedChildren = true;
          }
        }
        
        // Return the result if it has any selected children, otherwise null
        return hasSelectedChildren ? result : null;
      }
      
      // Default fallback
      return null;
    }
    
    /**
     * Finds a checkbox element by its path
     * @param {Array} path - Array of string segments representing the path
     * @returns {HTMLElement|null} - The checkbox element or null if not found
     */
    function findCheckboxByPath(path) {
      if (!path || !path.length) return null;
      
      // Build the path string used in the data-path attribute
      const pathString = path.join('.');
      
      // Try to find the checkbox directly using the path
      return document.querySelector(
        `input[type="checkbox"][data-path="${pathString}"]`
      );
    }
    
    // Propagate checkbox state to all children
    function propagateStateToChildren(checkbox, isChecked) {
      // Find the parent <li> of this checkbox
      const li = checkbox.closest('li');
      
      // Find all child checkboxes within this <li>
      const childCheckboxes = li.querySelectorAll('ul input[type="checkbox"]');
      
      // Set each child's checked state to match the parent
      childCheckboxes.forEach(childCheckbox => {
        childCheckbox.checked = isChecked;
        childCheckbox.indeterminate = false;
      });
    }
    
    // Update the state of all parent checkboxes
    function updateParentStates(checkbox) {
      // Find the parent <li> of this checkbox
      const li = checkbox.closest('li');
      
      // Get the parent <ul> and then its parent <li> (if any)
      const parentUl = li.parentElement;
      if (parentUl && parentUl.parentElement && parentUl.parentElement.tagName === 'LI') {
        const parentLi = parentUl.parentElement;
        const parentCheckbox = parentLi.querySelector('.checkbox-label-container > input[type="checkbox"]');
        
        // Check the state of all sibling checkboxes
        const siblingCheckboxes = Array.from(parentUl.querySelectorAll('li > .checkbox-item > .checkbox-label-container > input[type="checkbox"]'));
        
        // Count checked and total checkboxes
        const totalSiblings = siblingCheckboxes.length;
        const checkedSiblings = siblingCheckboxes.filter(cb => cb.checked).length;
        
        if (checkedSiblings === 0) {
          // None checked
          parentCheckbox.checked = false;
          parentCheckbox.indeterminate = false;
        } else if (checkedSiblings === totalSiblings) {
          // All checked
          parentCheckbox.checked = true;
          parentCheckbox.indeterminate = false;
        } else {
          // Some checked
          parentCheckbox.checked = false;
          parentCheckbox.indeterminate = true;
        }
        
        // Recursively update higher parent levels
        updateParentStates(parentCheckbox);
      }
    }
    
    // Setup tabs for the output area
    function setupOutputAreaTabs() {
      const outputTabButtons = document.querySelectorAll('#output-area-header .tab-button-group .tab-button');
      const outputTabContents = document.querySelectorAll('#output-area-code .output-code-content');

      outputTabButtons.forEach(button => {
        // Use passive option for touch events to improve scrolling performance
        button.addEventListener('touchstart', () => {
          // Deactivate all output tabs and hide all output content
          outputTabButtons.forEach(btn => btn.classList.remove('active'));
          outputTabContents.forEach(content => content.classList.remove('active'));

          // Activate the clicked button
          button.classList.add('active');

          // Show the target content
          const targetId = button.getAttribute('data-target');
          const targetContent = document.getElementById(targetId);
          if (targetContent) {
            targetContent.classList.add('active');
          }
          
          // Handle JS tab specific logic
          if (targetId === 'js-code-content') {
            handleJSTabActivation();
          }
          
          // Handle CSS tab specific logic
          if (targetId === 'css-code-content') {
            handleCSSTabActivation();
          }
          
          // Handle Tailwind tab specific logic
          if (targetId === 'tailwind-code-content') {
            handleTailwindTabActivation();
          }
        }, { passive: true });

        button.addEventListener('click', () => {
          // Deactivate all output tabs and hide all output content
          outputTabButtons.forEach(btn => btn.classList.remove('active'));
          outputTabContents.forEach(content => content.classList.remove('active'));

          // Activate the clicked button
          button.classList.add('active');

          // Show the target content
          const targetId = button.getAttribute('data-target');
          const targetContent = document.getElementById(targetId);
          if (targetContent) {
            targetContent.classList.add('active');
          }
          
          // Handle JS tab specific logic
          if (targetId === 'js-code-content') {
            handleJSTabActivation();
          }
          
          // Handle CSS tab specific logic
          if (targetId === 'css-code-content') {
            handleCSSTabActivation();
          }
          
          // Handle Tailwind tab specific logic
          if (targetId === 'tailwind-code-content') {
            handleTailwindTabActivation();
          }
        });
      });

      // Removing unused event listeners for action buttons that are placeholder only
      // These were causing console warnings without providing functionality
    }
    
    // Handle JS tab activation
    function handleJSTabActivation() {
      // Generate the filtered DTCG payload based on current selections
      const filteredDtcg = generateFilteredDtcgPayload();
      
      // Request JS code generation from the plugin
      parent.postMessage({ 
        pluginMessage: { 
          type: 'request-js-code',
          payload: filteredDtcg
        } 
      }, '*');
    }
    
    // Handle CSS tab activation
    function handleCSSTabActivation() {
      // Generate the filtered DTCG payload based on current selections
      const filteredDtcg = generateFilteredDtcgPayload();
      
      // Request CSS code generation from the plugin
      parent.postMessage({ 
        pluginMessage: { 
          type: 'request-css-code',
          payload: filteredDtcg
        } 
      }, '*');
    }
    
    // Handle Tailwind tab activation
    function handleTailwindTabActivation() {
      // Generate the filtered DTCG payload based on current selections
      const filteredDtcg = generateFilteredDtcgPayload();
      
      // Request Tailwind code generation from the plugin
      parent.postMessage({ 
        pluginMessage: { 
          type: 'request-tailwind-code',
          payload: filteredDtcg
        } 
      }, '*');
    }
    
    // Update the JSON view with the current payload
    function updateJsonView(payload) {
      const jsonViewer = document.querySelector('.json-viewer');
      const initialMessage = document.getElementById('json-initial-message');
      
      if (jsonViewer && initialMessage) {
        if (payload && Object.keys(payload).length > 0) {
          // Hide the initial message and show the JSON viewer
          initialMessage.style.display = 'none';
          jsonViewer.style.display = 'block';
          
          // Format the JSON with 2-space indentation
          jsonViewer.textContent = JSON.stringify(payload, null, 2);
        } else {
          // Payload is empty - show initial message
          initialMessage.style.display = 'block';
          jsonViewer.style.display = 'none';
          jsonViewer.textContent = ''; // Clear any previous JSON
        }
      }
    }
    
    // Update the JS view with the current payload  
    function updateJSView(jsPayload) {
      const jsCodeContent = document.getElementById('js-code-content');
      
      if (jsCodeContent) {
        // Handle the new payload structure with both code and structure
        if (jsPayload && typeof jsPayload === 'object' && jsPayload.code) {
          const jsCode = jsPayload.code;
          const structure = jsPayload.structure;
          
          if (jsCode && jsCode.trim() !== '{}') {
            // Create a container with two sections: structure and code
            jsCodeContent.innerHTML = `
              <div style="display: flex; flex-direction: column; height: 100%; gap: 12px;">
                <div style="flex: 1; min-height: 0;">
                  <h4 style="margin: 0 0 8px 0; color: #A0A0A0; font-size: 11px; font-weight: 500;">Object Structure</h4>
                  <div style="background: #2C2C2C; border-radius: 4px; padding: 12px; height: calc(100% - 32px); overflow-y: auto;">
                    <pre class="json-viewer" style="margin: 0;">${JSON.stringify(structure, null, 2)}</pre>
                  </div>
                </div>
                <div style="flex: 1; min-height: 0;">
                  <h4 style="margin: 0 0 8px 0; color: #A0A0A0; font-size: 11px; font-weight: 500;">Generated JavaScript Code</h4>
                  <div style="background: #2C2C2C; border-radius: 4px; padding: 12px; height: calc(100% - 32px); overflow-y: auto;">
                    <pre class="json-viewer" style="margin: 0;">${jsCode}</pre>
                  </div>
                </div>
              </div>
            `;
          } else {
            // Show placeholder message
            jsCodeContent.innerHTML = '<p style="margin: 0;">Select a collection, mode, or variable in the tree to view details.</p>';
          }
        } else if (typeof jsPayload === 'string') {
          // Handle legacy string payload (fallback)
          if (jsPayload && jsPayload.trim() !== '{}') {
            jsCodeContent.innerHTML = `<pre class="json-viewer">${jsPayload}</pre>`;
          } else {
            jsCodeContent.innerHTML = '<p style="margin: 0;">Select a collection, mode, or variable in the tree to view details.</p>';
          }
        } else {
          // Show placeholder message
          jsCodeContent.innerHTML = '<p style="margin: 0;">Select a collection, mode, or variable in the tree to view details.</p>';
        }
      }
    }
    
    // Update the CSS view with the current payload
    function updateCSSView(payload) {
      const cssCodeContent = document.getElementById('css-code-content');
      
      if (cssCodeContent) {
        if (payload && payload.code && payload.code.trim() !== '') {
          // Simply show the CSS code directly, like JS does
          cssCodeContent.innerHTML = `<pre class="json-viewer">${payload.code}</pre>`;
        } else {
          // Show placeholder message
          cssCodeContent.innerHTML = '<p style="margin: 0;">Select a collection, mode, or variable in the tree to view details.</p>';
        }
      }
    }
    
    // Update the Tailwind view with the current payload
    function updateTailwindView(payload) {
      const tailwindCodeContent = document.getElementById('tailwind-code-content');
      
      if (tailwindCodeContent) {
        if (payload && payload.code && payload.code.trim() !== '') {
          // Simply show the Tailwind code directly, like JS and CSS do
          tailwindCodeContent.innerHTML = `<pre class="json-viewer">${payload.code}</pre>`;
        } else {
          // Show placeholder message
          tailwindCodeContent.innerHTML = '<p style="margin: 0;">Select a collection, mode, or variable in the tree to view details.</p>';
        }
      }
    }

    // Setup download and copy button functionality
    function setupActionButtons() {
      const downloadBtn = document.getElementById('download-code-btn');
      const copyBtn = document.getElementById('copy-code-btn');
      const exportBtn = document.getElementById('export-github-btn');

      if (downloadBtn) {
        downloadBtn.addEventListener('click', () => {
          const data = getActiveCodeTabData();
          if (data) {
            // Create temporary anchor for download
            const blob = new Blob([data.content], { type: data.mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = data.filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }
        });
      }

      if (copyBtn) {
        copyBtn.addEventListener('click', async () => {
          const data = getActiveCodeTabData();
          if (data) {
            let copySuccess = false;
            
            try {
              // Primary method: Use legacy execCommand (more reliable in plugin contexts)
              const textarea = document.createElement('textarea');
              textarea.value = data.content;
              textarea.style.position = 'fixed';
              textarea.style.left = '-999999px';
              textarea.style.top = '-999999px';
              document.body.appendChild(textarea);
              textarea.focus();
              textarea.select();
              
              copySuccess = document.execCommand('copy');
              document.body.removeChild(textarea);
              
              // Fallback method: Modern Clipboard API
              if (!copySuccess && navigator.clipboard) {
                await navigator.clipboard.writeText(data.content);
                copySuccess = true;
              }
            } catch (error) {
              console.error('Failed to copy to clipboard:', error);
              copySuccess = false;
            }
            
            // Provide user feedback only if copy actually succeeded
            if (copySuccess) {
              const originalText = copyBtn.textContent;
              copyBtn.textContent = 'Copied';
              setTimeout(() => {
                copyBtn.textContent = originalText;
              }, 1000);
            } else {
              // Show failure feedback
              const originalText = copyBtn.textContent;
              copyBtn.textContent = 'Copy failed';
              setTimeout(() => {
                copyBtn.textContent = originalText;
              }, 1000);
            }
          }
        });
      }

      if (exportBtn) {
        exportBtn.addEventListener('click', () => {
          // Handle export button click
          console.log('Export to Github button clicked');
        });
      }
    }

    // Helper function to get active code tab data
    function getActiveCodeTabData() {
      const activeTabButton = document.querySelector('#output-area-header .tab-button-group .tab-button.active');
      if (!activeTabButton) return null;

      const targetId = activeTabButton.getAttribute('data-target');
      const contentPane = document.getElementById(targetId);
      if (!contentPane) return null;

      let content = '';
      let type = '';
      let filename = '';
      let mimeType = '';

      switch (targetId) {
        case 'json-code-content':
          const jsonViewer = contentPane.querySelector('.json-viewer');
          content = jsonViewer ? jsonViewer.textContent : '';
          type = 'json';
          filename = 'variables.json';
          mimeType = 'application/json';
          break;
        case 'js-code-content':
          // More robust JS content retrieval
          // First, try to find the "Generated JavaScript Code" section (two-section structure)
          const generatedCodeHeaders = Array.from(contentPane.querySelectorAll('h4'));
          const generatedCodeHeader = generatedCodeHeaders.find(h => h.textContent === 'Generated JavaScript Code');
          
          if (generatedCodeHeader && generatedCodeHeader.nextElementSibling) {
            const codeContainer = generatedCodeHeader.nextElementSibling;
            const codeViewer = codeContainer.querySelector('.json-viewer');
            content = codeViewer ? codeViewer.textContent : '';
          } else {
            // Fallback: try to get content from a single pre element (legacy case)
            const singleJsViewer = contentPane.querySelector('.json-viewer');
            content = singleJsViewer ? singleJsViewer.textContent : '';
          }
          
          type = 'js';
          filename = 'variables.js';
          mimeType = 'application/javascript';
          break;
        case 'css-code-content':
          const cssViewer = contentPane.querySelector('.json-viewer');
          content = cssViewer ? cssViewer.textContent : '';
          type = 'css';
          filename = 'variables.css';
          mimeType = 'text/css';
          break;
        case 'tailwind-code-content':
          const tailwindViewer = contentPane.querySelector('.json-viewer');
          content = tailwindViewer ? tailwindViewer.textContent : '';
          type = 'tailwind';
          filename = 'tailwind.config.js';
          mimeType = 'application/javascript';
          break;
        default:
          return null;
      }

      return (content && content.trim() !== '') ? { content, type, filename, mimeType } : null;
    }
  </script>
</body>
</html> 