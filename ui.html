<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --figma-color-text: #FFFFFF;
      --tab-wrapper-bg: #2C2C2C;
      --tab-wrapper-border: #444444;
      --tab-button-padding: 6px 10px;
      --tab-button-radius: 4px;
      --tab-button-font: inherit;
      --tab-button-font-size: 11px;
      --tab-button-font-weight: 500;
      --tab-button-letter-spacing: normal;
      --tab-default-text-color: #A0A0A0;
      --tab-default-opacity: 1;
      --tab-active-text-color: #FFFFFF;
      --tab-active-opacity: 1;
      --tab-active-bg: #3C3C3C; 
    }

    body {
      font-family: 'Geist Mono', 'Roboto Mono', monospace; /* Changed from Inter */
      margin: 0;
      font-size: 11px;
      color: var(--figma-color-text);
      min-height: 0; /* Keeping this for now, might be useful for nested flex */
      overflow: hidden;
      /* display: flex; Removed to allow container to fill body */
      height: 100vh; /* Make body take full viewport height */
    }

    .tab-wrapper {
      display: flex;
      flex-shrink: 0;
      padding: 10px; /* Correct */
      /* gap: 2px; Removed - moved to inner group */
      background-color: var(--tab-wrapper-bg); /* Correct (#2C2C2C) */
      border-bottom: 1px solid var(--tab-wrapper-border); /* Corrected typo and Correct (#444444) */
      /* width: 100%; Removed - Should hug content based on Figma */
      /* box-sizing: border-box; Removed */
      align-items: center; /* Added */
    }

    /* New inner container for buttons to apply the gap */
    .tab-button-group {
        display: flex;
        align-items: center;
        gap: 2px; /* Gap applied here, as in Figma's inner Frame 7 */
    }

    .tab-wrapper .tab-button { /* Specificity remains sufficient */
      padding: var(--tab-button-padding);
      border-radius: var(--tab-button-radius);
      font-family: var(--tab-button-font);
      font-size: var(--tab-button-font-size);
      font-weight: var(--tab-button-font-weight);
      letter-spacing: var(--tab-button-letter-spacing);
      border: none;
      background: none;
      cursor: pointer;
      text-align: center;
      /* Default State */
      color: var(--tab-default-text-color);
      opacity: var(--tab-default-opacity);
      transition: background-color 0.2s, color 0.2s, opacity 0.2s;
    }

    .tab-wrapper .tab-button.active { /* Increased specificity */
      color: var(--tab-active-text-color);
      opacity: var(--tab-active-opacity);
      background-color: var(--tab-active-bg);
    }

    .tab-wrapper .tab-button:hover:not(.active) { /* Increased specificity */
       /* Use active style for hover based on Figma */
      color: var(--tab-active-text-color);
      opacity: var(--tab-active-opacity);
      background-color: var(--tab-active-bg);
    }

    /* View containers / Tab Content */
    .tab-content {
      display: none;
      height: 100%;
      overflow: auto;
      box-sizing: border-box;
    }

    .tab-content.active {
      display: flex;
      flex-direction: row;
      width: 100%;
      /* No gap here, border on tree-area handles separation */
    }

    .views-container {
      display: flex;
      flex-grow: 1;
      min-height: 0;
      overflow: hidden; /* or auto */
    }

    .container {
      display: flex;
      flex-direction: row; /* Changed from column to row for horizontal layout */
      height: 100%;
      width: 100%; /* ADDED */
      overflow: hidden; /* Prevent unwanted scrollbars */
    }
    
    .header {
      display: none; /* Hide the header */
    }
    
    /* Flex wrapper for main content areas */
    .content-wrapper {
      display: flex;
      flex-direction: column; /* Keep column for tabs on top */
      flex-grow: 1;
      min-height: 0; /* Important for nested flex containers */
      overflow: hidden;
    }

    #tree-area {
      flex-basis: 33%; /* Takes roughly 1/3 of the space */
      flex-grow: 1;
      max-width: 30%; /* Added to cap width */
      padding: 12px; /* Updated from 10px */
      border-right: 1px solid var(--tab-wrapper-border); /* Consistent border */
      box-sizing: border-box;
      overflow-y: auto; /* Allow scrolling if content overflows */
      display: flex; /* Added for internal layout */
      flex-direction: column; /* Added for internal layout */
      gap: 12px; /* Added for internal layout */
    }

    #output-area {
      flex-basis: 67%; /* Takes roughly 2/3 of the space */
      flex-grow: 1;
      padding: 12px; /* Updated from 10px */
      box-sizing: border-box;
      overflow-y: auto; /* Allow scrolling if content overflows */
      display: flex; /* Added for internal layout */
      flex-direction: column; /* Added for internal layout */
      gap: 12px; /* Added for internal layout */
    }

    /* Tree view styles */
    .tree-item {
      margin-bottom: 4px;
      cursor: pointer;
    }

    .tree-item-header {
      display: flex;
      align-items: center;
      padding: 4px 8px;
      border-radius: 4px;
      user-select: none;
    }

    .tree-item-header:hover {
      background-color: var(--tab-active-bg);
    }

    .tree-item-header.selected {
      background-color: var(--tab-active-bg);
      font-weight: bold;
    }

    .tree-item-toggle {
      margin-right: 4px;
      transform: rotate(0deg);
      transition: transform 0.2s;
    }

    .tree-item-toggle.open {
      transform: rotate(90deg);
    }

    .tree-item-children {
      margin-left: 16px;
      display: none;
    }

    .tree-item-children.open {
      display: block;
    }

    /* Spinner for loading state */
    .spinner {
      width: 40px;
      height: 40px;
      margin: 20px auto;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--figma-color-text);
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* JSON viewer styles */
    pre.json-viewer {
      background-color: #1E1E1E;
      border-radius: 4px;
      padding: 12px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.5;
      color: var(--figma-color-text);
    }

    .json-viewer .string { color: #CE9178; }
    .json-viewer .number { color: #B5CEA8; }
    .json-viewer .boolean { color: #569CD6; }
    .json-viewer .null { color: #569CD6; }
    .json-viewer .key { color: #9CDCFE; }
    .json-viewer .alias-path { color: #DCDCAA; }
  </style>
</head>
<body>
  <div class="container">
    <!-- The old header is hidden -->
    <!-- <div class="header">...</div> -->
    
    <div class="content-wrapper">
      <!-- New Tab Navigation -->
      <div class="tab-wrapper">
        <div class="tab-button-group"> <!-- Added inner group -->
          <button class="tab-button active" data-target="variables-view">Variables</button>
          <button class="tab-button" data-target="styles-view">Styles</button>
          <button class="tab-button" data-target="github-view">Export to Github</button>
          <button class="tab-button" data-target="settings-view">Settings</button>
        </div> <!-- Closed inner group -->
      </div>
      
      <!-- Old view selector removed -->
      <!-- <div class="view-selector-container">...</div> -->

      <div class="views-container">
        <!-- Variables View -->
        <div class="tab-content active" id="variables-view">
          <div id="tree-area">
            <div id="variables-tree">
              <div class="spinner"></div>
            </div>
          </div>
          <div id="output-area">
            <div id="variables-output">
              <p>Select a collection, mode, or variable in the tree to view details.</p>
            </div>
          </div>
        </div>
      
        <!-- Styles View -->
        <div class="tab-content" id="styles-view">
          <div id="tree-area">
            Tree Area (Styles)
          </div>
          <div id="output-area">
            Output Area (Styles)
          </div>
        </div>
        
        <!-- GitHub Export View (Placeholder) -->
        <div class="tab-content" id="github-view">
          <div id="output-area">
            Output Area (Github)
          </div>
         </div>

        <!-- Settings View (Placeholder) -->
         <div class="tab-content" id="settings-view">
          <div id="output-area">
            Output Area (Settings)
          </div>
         </div>

      <!-- The output-section that was here is now removed -->
      </div> <!-- End of views-container -->
    </div>
  </div>
  <script>
    // Global state
    let variablesData = null;
    let selectedTreeItem = null;

    // Document ready event
    document.addEventListener('DOMContentLoaded', function () {
      // Tab switching logic
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          // Deactivate all buttons and hide all content
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));

          // Activate the clicked button
          button.classList.add('active');

          // Show the target content
          const targetId = button.getAttribute('data-target');
          const targetContent = document.getElementById(targetId);
          if (targetContent) {
            targetContent.classList.add('active');
          }
        });
      });

      // Message handler from the plugin
      window.onmessage = event => {
        const message = event.data.pluginMessage;
        
        if (!message) return;
        
        if (message.type === 'plugin-ready') {
          console.log('Plugin is ready, fetching variables');
          parent.postMessage({ pluginMessage: { type: 'fetch-variables' } }, '*');
        }
        else if (message.type === 'variables-data') {
          console.log('Received variables data');
          variablesData = message.payload;
          hideSpinner();
          buildVariablesTree();
        }
        else if (message.type === 'error') {
          console.error('Error:', message.message);
          hideSpinner();
          document.getElementById('variables-tree').innerHTML = `
            <div style="color: red; padding: 10px;">
              Error fetching variables: ${message.message}
            </div>
          `;
        }
      };
    });

    // Utility functions
    function hideSpinner() {
      const spinner = document.querySelector('.spinner');
      if (spinner) spinner.style.display = 'none';
    }

    function buildVariablesTree() {
      const treeContainer = document.getElementById('variables-tree');
      treeContainer.innerHTML = '';
      
      if (!variablesData || Object.keys(variablesData).length === 0) {
        treeContainer.innerHTML = '<p>No variables found in this document.</p>';
        return;
      }
      
      // Create tree structure
      for (const collectionName in variablesData) {
        const collectionItem = createTreeItem(collectionName, 'collection');
        treeContainer.appendChild(collectionItem);
        
        const collectionChildren = collectionItem.querySelector('.tree-item-children');
        const collection = variablesData[collectionName];
        
        for (const modeName in collection) {
          const modeItem = createTreeItem(modeName, 'mode');
          collectionChildren.appendChild(modeItem);
          
          const modeChildren = modeItem.querySelector('.tree-item-children');
          const mode = collection[modeName];
          
          // First pass: find all groups and direct variables
          const groups = {};
          const directVariables = {};
          
          for (const key in mode) {
            if (typeof mode[key] === 'object' && mode[key] !== null && !Array.isArray(mode[key])) {
              // This is a group
              groups[key] = mode[key];
            } else {
              // This is a direct variable
              directVariables[key] = mode[key];
            }
          }
          
          // Add direct variables first
          for (const varName in directVariables) {
            const varItem = createTreeItem(varName, 'variable');
            modeChildren.appendChild(varItem);
          }
          
          // Add groups
          for (const groupName in groups) {
            const groupItem = createTreeItem(groupName, 'group');
            modeChildren.appendChild(groupItem);
            
            const groupChildren = groupItem.querySelector('.tree-item-children');
            const group = groups[groupName];
            
            for (const varName in group) {
              const varItem = createTreeItem(varName, 'variable');
              groupChildren.appendChild(varItem);
            }
          }
        }
      }
      
      // Add click handlers
      addTreeItemHandlers();
    }

    function createTreeItem(name, type) {
      const item = document.createElement('div');
      item.className = 'tree-item';
      item.dataset.type = type;
      item.dataset.name = name;
      
      const header = document.createElement('div');
      header.className = 'tree-item-header';
      
      const toggle = document.createElement('span');
      toggle.className = 'tree-item-toggle';
      toggle.textContent = '►';
      header.appendChild(toggle);
      
      const label = document.createElement('span');
      label.className = 'tree-item-label';
      label.textContent = name;
      header.appendChild(label);
      
      const children = document.createElement('div');
      children.className = 'tree-item-children';
      
      item.appendChild(header);
      item.appendChild(children);
      
      return item;
    }

    function addTreeItemHandlers() {
      const treeItems = document.querySelectorAll('.tree-item-header');
      
      treeItems.forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          
          const parent = item.parentElement;
          const toggle = item.querySelector('.tree-item-toggle');
          const children = parent.querySelector('.tree-item-children');
          
          // Toggle the item's children
          toggle.classList.toggle('open');
          children.classList.toggle('open');
          
          // Set as selected
          if (selectedTreeItem) {
            selectedTreeItem.classList.remove('selected');
          }
          item.classList.add('selected');
          selectedTreeItem = item;
          
          // Show details in output area
          showItemDetails(parent);
        });
      });
    }

    function showItemDetails(item) {
      const type = item.dataset.type;
      const name = item.dataset.name;
      const outputArea = document.getElementById('variables-output');
      
      // Build the path to this item
      let path = [];
      let current = item;
      
      while (current && current.dataset && current.dataset.name) {
        path.unshift(current.dataset.name);
        // Get parent tree item
        current = current.parentElement.closest('.tree-item');
      }
      
      // Get the data
      let data = variablesData;
      for (const segment of path) {
        if (data) data = data[segment];
      }
      
      // Render the output
      if (data) {
        outputArea.innerHTML = `
          <h3>${path.join(' → ')}</h3>
          <pre class="json-viewer">${formatJSON(data, type)}</pre>
        `;
      } else {
        outputArea.innerHTML = `<p>No data available for ${path.join(' → ')}</p>`;
      }
    }

    function formatJSON(data, type) {
      if (typeof data !== 'object' || data === null) {
        if (typeof data === 'string' && data.startsWith('$')) {
          // This is an alias path
          return `<span class="alias-path">${data}</span>`;
        } else if (typeof data === 'string') {
          return `<span class="string">"${data}"</span>`;
        } else if (typeof data === 'number') {
          return `<span class="number">${data}</span>`;
        } else if (typeof data === 'boolean') {
          return `<span class="boolean">${data}</span>`;
        } else if (data === null) {
          return `<span class="null">null</span>`;
        }
        return String(data);
      }
      
      if (Array.isArray(data)) {
        const items = data.map(item => formatJSON(item, type)).join(',\n');
        return `[\n  ${items.replace(/\n/g, '\n  ')}\n]`;
      }
      
      const keys = Object.keys(data);
      if (keys.length === 0) return '{}';
      
      const items = keys.map(key => {
        return `<span class="key">"${key}"</span>: ${formatJSON(data[key], type)}`;
      }).join(',\n');
      
      return `{\n  ${items.replace(/\n/g, '\n  ')}\n}`;
    }
  </script>
</body>
</html> 